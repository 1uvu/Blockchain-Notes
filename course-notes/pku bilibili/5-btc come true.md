区块链是一个去中心化的账本，而比特币采取的是基于交易的账本模式（transaction-based ledger）

### 基于交易

区块中只会存储交易记录，而不会显式的存储账户余额，这需要通过交易记录推算，需要显式地说明币的来源。

区块链的全节点需要维护一个称为 UTXO（Unspent Transaction Output）的数据结构，即还没有被花出去的（交易的输出）。

上面这句话可以这样理解：之前学习过，每一条交易记录都有一个输入和输出，输入给出币的来源，输出是币收款人的公钥的哈希，那么没有被花出去的交易的输出指的就是一个收款者通过交易得到的且没有花费的币。

一个交易可能有多个输出，没有被花，也就是从未做输入的币，都在 UTXO 这个结构中。

因此，每一个交易都会“消耗”一些没有被花出去的交易输出，作为新交易的输入，同时产生新的没有被花出去的交易输出。

只需给出产生交易输出的交易的哈希值，以及这个元素在这个交易中的序号，就可以定位到 UTXO 的一个元素

想要交易的币必须在 UTXO 集合中才是合法的，这样可以快速检测 double spending。

显然，对于所有交易输入之和需要与所有交易输出之和相等（total inputs = total outputs）。

一般情况下，输入和输出会有差值，差值提供给发布区块的记账者，作为交易费或手续费。这是比特币中的第二个激励机制，交易费（transaction fee）激励。

目前的交易费很少，所以矿工的挖坑初衷还是得到出块奖励，但是由于每隔四年（21w 个区块，每个块 10min）出块奖励减半，在将来矿工获取利益的方式主要为交易费（那时交易费会变多）。

### 基于账户（account-based ledger）

系统会显式地记录账户余额。



### 区块结构（来源于 [blockchain.com](https://www.blockchain.com/)）

| Key                    | Comment                                                    | Value                                                        |
| ---------------------- | :--------------------------------------------------------- | ------------------------------------------------------------ |
| Hash                   | 块头哈希，根据挖坑原理可知，前面的 0 越多，挖坑难度越大。  | 0000000000000000000b660169701bd642482816755dcdf7b3328093e6346180 |
| Confirmations          |                                                            | 3                                                            |
| Timestamp              | 区块产生时间                                               | 2020-06-08 14:11                                             |
| Height                 | 区块序号                                                   | 633666                                                       |
| Miner                  | 矿工                                                       | [BTC.com](https://www.blockchain.com/btc/address/bc1qjl8uwezzlech723lpnyuza0h2cdkvxvh54v3dn) |
| Number of Transactions | 交易数目                                                   | 1,120                                                        |
| Difficulty             | 挖坑难度，每隔 2016 个区块，调整难度，保证出块时间在 10min | 13,732,352,106,018.34                                        |
| Merkle root            | Merkle root 哈希                                           | d9be94cebcdf8a7271d1983487dc68dfd7e5195864cb4a92b83ee857341336ef |
| Version                | BTC 版本                                                   | 0x20000000                                                   |
| Bits                   |                                                            | 387,219,253                                                  |
| Weight                 |                                                            | 1,587,389 WU                                                 |
| Size                   |                                                            | 541,388 bytes                                                |
| Nonce                  | 挖矿时最后找到的符合难度要求的随机数                       | 545,701,349                                                  |
| Transaction Volume     | 交易总量                                                   | 3195.10906453 BTC                                            |
| Block Reward           | 出块奖励                                                   | 6.25000000 BTC                                               |
| Fee Reward             | 交易费                                                     | 0.09215099 BTC                                               |

由于，挖坑的竞争越来越大，4bytes 的 nonce 字段不够用了（会出现找不到 nonce 满足 target 的情况），因此可以通过修改 Merkle hash 来扩展，原理和过程如下：

由于区块在初次出现时，会进行铸币交易，这是区块的第一笔交易，铸币交易是产生新的比特币的唯一方式，而这个交易没有输入，因此与输入对应的 Coin Base 域可以写入任意内容。

所以，写入的 Coin Base Transaction内容最终会影响 Merkle hash 的值。

进一步，可以将 Coin Base 域的一部分字节作为 Extra Nonce 来用，这就扩展了 Nonce 的范围。

因此，实际的挖坑过程往往有两层循环，第一层调整 extra nonce，并算出 Merkle hash，内层循环再调整 nonce，最终得到适合的 nonce。

### 挖坑的概率分析

挖坑就是不断的尝试各种 nonce，来求解 puzzle，对于 nonce 的每一次尝试都可以视为一次伯努利试验（Bernoulli trial: A random experiment with binary outcome），成功概率非常小，失败概率非常高，不成功便失败。

所有试验就构成了伯努利过程（Bernoulli process: A sequence of independent Bernoulli trials）

这个过程的一个性质是无记忆性（memoryless）或者（process free），每个试验直接互不影响，因此可以使用泊松过程（Poisson process）来近似。

比特币系统中的挖坑关心的是出块时间，从概率学角度推导，出块时间符合指数分布。

无记忆性保证了挖坑的公平性。

### 比特币的总量

几何序列（geometric series）

21w x 50btc + 21w x 25 + ...

= 21w x 50btc x (1 + 0.5 + 0.25 + ...) = 2100wbtc

Bitcoin is secured by mining，只要系统的大部分算力掌握在诚实的节点上，系统就是安全的。

但是，挖坑只保证了记账权大概率会给到诚实的节点，但是还是会有恶意节点得到记账权，此时可能出现两个问题，下面探讨一下这些问题的可能性以及解决方法：

首先，判断一个攻击是否有效的标准是：诚实的节点会不会认可这个攻击。

1. 偷币问题

   将一个交易硬写入一个恶意区块中，这样的攻击是不会生效的，因为诚实的节点会跳过这个有问题的区块，将新的区块写到这个恶意区块前面的那一个区块后，此时就会产生分叉，根据之前学习的最长有效链原则，这个恶意区块不光偷不到币，还会损失掉出币奖励。

2. 花两次问题

   当获取到记账权的恶意节点试图进行花两次操作时，由于区块链对于花两次攻击的防范（哈希指针），新的区块需要插入到恶意区块的前面的那个区块上，此时又出现了分叉。

   区块插入的位置，在挖坑的一开始就是确定的，而不是在挖矿完成之后再确定，因为之前已经学过，挖坑操作中涉及到的 block header 需要填上前一个区块的哈希。

   需要注意的是，当恶意区块之后已经有了一些其它区块时，上述的分叉攻击十分困难，因为大部分的算力是掌握在诚实节点手上的。

   比特币中采取了多等几个（比特币缺省为等待 6 个确认）确认（confirmation）的机制，也就是当在一个区块后面已经连接了 6 个区块之后，才可以认为这个区块是不可篡改的。

   因此，区块链中的不可篡改性也是基于概率的。

   继续考虑，假如恶意节点挖到了 7 个区块，藏起来不急着写入，等到待插入的区块之后有了 6 个区块时，再将 7 个区块全部写到链上，覆盖掉原来的 7 个，这种攻击称为（selfish mining）

   当然，不一定是要 7 个，只要比原来的链的区块数量多，在一起发出去就称为 selfish mining，这种攻击最终比拼的还是算力，因此无法杜绝，但是风险很大，且藏的区块越多风险越大。

   