# Rust 学习笔记（九）：Rust Trait，定义泛型的行为

此部分内容为原文档第十章《泛型、trait 和生命周期》中第二部分关于 *trait* 的内容，将拆为三部分来学习。

定义泛型的行为也可称为定义可共享的行为，即对于不同类型如果调用相同的方法，这些类型就可以共享相同的行为，这些类型也就可以抽象为泛型。

可以把 trait 简单地概括为**可继承**及**可默认实现**的 Java **接口**。

## Content

[TOC]

【需要重新组织目录】

## 定义 trait

trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。

如：

```rust
pub trait Display {
	fn fmt(&self) -> String;
    /*
    罗列方法签名
    */
}
```



## 为类型实现 trait

使用 `impl` 声明实现，并使用 `for` 指定实现的类型。

如：

```rust
pub struct Point {
	x: i32,
	y: i32,
}

impl Display for Point {
	fn fmt(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}
```

在实现时有如下规则：

- **实现完整**。
- **相干性**（*coherence*），或者更具体的说是 **孤儿规则**（*orphan rule*）。只能为类型实现内部作用域中定义或是导入的 trait。
- **默认实现**。当存在默认实现时，已经默认实现的方法可以不必再次实现，也可再次实现来覆盖原有的默认实现。

## trait 的继承

这是第一个与 Java 接口所不同的区别。看一个百度来的例子：

```rust
use std::fmt;

fn main() {

    struct Point {
        x: i32,
        y: i32,
    }

    // OutlinePrint 这个 trait 继承 fmt::Display, 
    // 并提供一个额外的 outline_print 功能.
    trait OutlinePrint: fmt::Display {
        // outline_print 是一个默认实现功能函数.
        fn outline_print(&self) {
            let output = self.to_string();
            println!("{}", output);
        }
    }

    // 这里可以仅声明一下 Point 拥有这个 trait 即可.
    // 也可和下面的代码一样, 覆盖默认实现.
    impl OutlinePrint for Point {
        fn outline_print(&self) {
            let output = self.to_string();
            let len = output.len();
            println!("{}", "*".repeat(len + 4));
            println!("*{}*", " ".repeat(len + 2));
            println!("* {} *", output);
            println!("*{}*", " ".repeat(len + 2));
            println!("{}", "*".repeat(len + 4));
        }
    }
    
    // 这里仍然需要声明 Point 拥有 fmt::Display, 这是 Rust 的语法要求.
    impl fmt::Display for Point {
        
        // 为什么这里要写这个方法?
        // 那是因为fmt::Display只是定义了一个接口, 并没有实现这个方法.
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "({}, {})", self.x, self.y)
        }
    }

    let p = Point {x: 1, y: 2};
    p.outline_print();

    // output:
    /*
    **********
    *        *
    * (1, 2) *
    *        *
    **********
    */
}
```



## trait 作为参数



## 返回实现了 trait 的类型



## 使用 trait bounds 来修复 `largest` 函数



## 使用 trait bound 有条件地实现方法



